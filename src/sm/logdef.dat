# <std-header style='data' orig-src='shore'>
#
#  $Id: logdef.dat,v 1.67 2010/10/27 17:04:23 nhall Exp $
#
#
# (c) Copyright 2013, Hewlett-Packard Development Company, LP
#
#
# SHORE -- Scalable Heterogeneous Object REpository
#
# Copyright (c) 1994-99 Computer Sciences Department, University of
#                       Wisconsin -- Madison
# All Rights Reserved.
#
# Permission to use, copy, modify and distribute this software and its
# documentation is hereby granted, provided that both the copyright
# notice and this permission notice appear in all copies of the
# software, derivative works or modified versions, and any portions
# thereof, and that both notices appear in supporting documentation.
#
# THE AUTHORS AND THE COMPUTER SCIENCES DEPARTMENT OF THE UNIVERSITY
# OF WISCONSIN - MADISON ALLOW FREE USE OF THIS SOFTWARE IN ITS
# "AS IS" CONDITION, AND THEY DISCLAIM ANY LIABILITY OF ANY KIND
# FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
#
# This software was developed with support by the Advanced Research
# Project Agency, ARPA order number 018 (formerly 8230), monitored by
# the U.S. Army Research Laboratory under contract DAAB07-91-C-Q518.
# Further funding for this work was provided by DARPA through
# Rome Research Laboratory Contract No. F30602-97-2-0247.
#
#   -- do not edit anything above this line --   </std-header>

#########################################################################
#                                                                       #
#    WARNING: if you add, delete or change any of the log records,      #
#    or their data members, or their semantics you also need to         #
#    update log_base::version_major and/or log_base::version_minor      #
#    in log_base.cpp.                                                   #
#                                                                       #
#       For every log record type, the perl script generates a class    #
#       class <type>_log {                                              #
#           void fill(const lpid_t*p, uint16_t tag, int len);           #
#       public:                                                         #
#           <type>_log(<arg>);                                          #
#        // and...                                                      #
#        // iff R bit set:                                              #
#        void redo(generic_page_h *page);                               #
#        // iff U bit set:                                              #
#        void undo(generic_page_h *page);                               #
#       }                                                               #
#                                                                       #
#    The format of the file is as follows:                              #
#        type = log record type                                         #
#        X    = transaction log (generated by transactions)             #
#                      If set, logstub_gen.cpp contains a function      #
#                      rc_t log_<type> (<arg>) to generate the log recs #
#                      according to convention.  If not, the code else- #
#                      where in the SM has to be written by hand to gen #
#                      the log record.                                  #
#        S    = Single-System Transaction Log                           #
#               If this is true, begin/commit is fused to one log entry #
#        R    = redoable    (-->t_redo bit set in log record)           #
#                      Includes redo method in class                    #
#        U    = undoable    (-->t_undo)                                 #
#                      Includes undo method in class                    #
#        F    = format    NOT USED                                      #
#        A    = space-allocation:                                       #
#                      If NOT set, generated code decides if logging    #
#                      should be done, based on :                       #
#                      1) smlevel_1::log, smlevel_0::logging_enabled,   #
#                      2) (if page argument present) page.store_flags   #
#                                            == st_tmp                  #
#                      3) xct() attached and xct()->is_log_on()         #
#                                                                       #
#                      If A bit IS SET, checks #2, #3 are left out      #
#                                                                       #
#        L    = logical undo log record -- don't fix the page           #
#                                        for undo.  Irrelevant if not   #
#                      an undoable log record.                          #
#                      --> t_logical                                    # 
#                                                                       #
#        fudge = observed fudge factor for log space reservations       #
#                                                                       #
#        arg  = arguments to constructor                                #
#                      SPECIAL CASE: first argument is "page":          #
#                      1) store flags checked to turn off logging for   #
#                      st_tmp files.                                    #
#                      2) give_logbuf() call passes page for 2nd arg    #
#                      3) page.set_dirty() if logging is skipped        #
#                                    #
#########################################################################
# type             XSRUFAL  fudge    arg                                #
#########################################################################
comment            1011001 1.0 (const char* msg);
compensate         1000001 0.0 (const lsn_t& rec_lsn);
skip               0000000 0.0 ();
chkpt_begin        0000000 0.0 (const lsn_t &lastMountLSN);
chkpt_bf_tab       0000000 0.0 (int cnt, const lpid_t* pid,
                            const lsn_t* rec_lsn);
chkpt_xct_tab      0000000 0.0 (const tid_t& youngest, 
                            int cnt, const tid_t* tid, 
                            const smlevel_1::xct_state_t* state,
                            const lsn_t* last_lsn, const lsn_t* undo_nxt);
chkpt_dev_tab      0000000 0.0 (int cnt, const char** dev_name, const vid_t* vid);
chkpt_end          0000000 0.0 (const lsn_t& master, const lsn_t& min_rec_lsn);
mount_vol          0010010 0.0 (const char *dev_name, const vid_t &vid);
dismount_vol       0010010 0.0 (const char *dev_name, const vid_t &vid);
#########################################################################
# type             XSRUFAL  fudge    arg                                #
#########################################################################
xct_abort          1000000 0.0 ();
xct_freeing_space  1000000 0.0 ();
xct_end            1000000 0.0 ();
xct_end_group      1000000 0.0 (const xct_t** l, int llen);
xct_prepare_st     1010000 0.0 (const gtid_t* g, const server_handle_t& h);
xct_prepare_lk     1010000 0.0 (int num, lock_mode_t mode, lockid_t* lks);
xct_prepare_alk    1010000 0.0 (int num, lockid_t* lks, lock_mode_t* modes);
xct_prepare_stores 1010000 0.0 (int num, const stid_t* stids);
xct_prepare_fi     1010000 0.0 (int numex, int numix, int numsix, const lsn_t& first, int rsvd, int ready, int used);
#########################################################################
# type             XSRUFAL  fudge    arg                                #
#########################################################################
# new page allocation logs. No notion of extent. no undo in any case.
alloc_a_page       1110010  1.0  (vid_t vid, shpid_t pid);
alloc_consecutive_pages 1110010  1.0  (vid_t vid, shpid_t pid_begin, uint32_t page_count);
dealloc_a_page     1110010  1.0  (vid_t vid, shpid_t pid);
store_operation    1011011 1.0 (const store_operation_param& op);
#########################################################################
# type             XSRUFAL  fudge    arg                                #
#########################################################################
# This just sets the status of the page to "to-be-deleted".
# Once the page is actually deleted by bufferpool, we can't UNDO it.
page_set_tobedeleted   1011000 1.0 (const generic_page_h& page);

# This is a special way of logging the creation of a new page.
# New page creation is usually a page split, so the new page has many
# records in it. To simplify and to avoid many log entries in that case,
# we log ALL bytes from the beginning to the end of slot vector,
# and from the record_head to the end of page.
# We can assume totally defragmented page image because this is page creation.
# We don't need UNDO (again, this is page creation!), REDO is just two memcpy().
page_img_format   1011000 1.0 (const btree_page_h& page);

#########################################################################
# type             XSRUFAL  fudge    arg                                #
#########################################################################
btree_insert       1011001 1.42 (const btree_page_h& page, 
                            const w_keystr_t& key, const cvec_t& el);

btree_update       1011001 1.42 (const btree_page_h& page, const w_keystr_t& key,
    const char* old_el, int old_elen, const cvec_t& new_el);

btree_overwrite    1011001 1.00 (const btree_page_h& page, const w_keystr_t& key,
    const char* old_el, const char* new_el, size_t offset, size_t elen);

# We only need to log these header items. Other items are immutable.
btree_header       1011000 1.22 (const btree_page_h& page, shpid_t btree_pid0,
    int16_t btree_level, shpid_t btree_foster,
    int16_t btree_chain_fence_high_length);

# ghost records. currently only for BTrees as their UNDO/REDO rely on BTree access.
btree_ghost_mark    1011001 1.0  (const btree_page_h& page, const vector<slotid_t>& slots);
btree_ghost_reclaim 1110000 1.0  (const btree_page_h& page, const vector<slotid_t>& slots);
# ghost reservation is fused
btree_ghost_reserve 1110000 1.0  (const btree_page_h& page, const w_keystr_t& key, int record_size);

# page is the foster-parent page.
# if it's intermediate node. this is combined with adopt that caused the split.
btree_foster_split   1010000 1.0 (const btree_page_h& page, shpid_t new_pid, int32_t right_begins_from,
    const w_keystr_t* new_child_key, shpid_t new_child_pid);

# for extremely skewed split (no-record move).
btree_foster_norecord_split 1010000 1.0 (const btree_page_h& page, shpid_t foster,
    const w_keystr_t& fence_high, const w_keystr_t& chain_fence_high);

# log for parent/child. child needs really nothing as log
btree_foster_adopt_parent  1010000 1.0 (const btree_page_h& page, shpid_t new_child_pid, const w_keystr_t& new_child_key);
btree_foster_adopt_child   1010000 1.0 (const btree_page_h& page);

# no other arg because it always merges its foster-child.
btree_foster_merge          1010000 1.0 (const btree_page_h& page);

# "page" is the foster-child, which receives entries.
btree_foster_rebalance      1010000 1.0 (const btree_page_h& page,
    shpid_t parent_pid, int32_t move_count);

# log for each page (real-parent and foster-parent).
# foster_slot: the slot to be foster-parent. 0=pid0.
btree_foster_deadopt_real_parent   1010000 1.0 (const btree_page_h& page,
    shpid_t deadopted_pid, int32_t foster_slot);
btree_foster_deadopt_foster_parent 1010000 1.0 (const btree_page_h& page, shpid_t deadopted_pid,
    const w_keystr_t& low_key, const w_keystr_t& high_key);

# A special empty log just for updating LSN of the page.
btree_noop                      1000000 1.0 (const btree_page_h& page);

#########################################################################
# type             XSRUFAL  fudge    arg                                #
#########################################################################
