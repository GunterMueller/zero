#ifndef XCT_LOGGER_H
#define XCT_LOGGER_H

#include "sm.h"
#include "btree_page_h.h"
#include "logdef_gen.h"
#include "log_core.h"

class XctLogger
{
public:

    /*
     * This method replaces the old log "stubs" that were generated by a Perl
     * script logdef.pl. Two overloads are required because of the cumbersome
     * way in which PageLSNs are managed in Zero (see xct_t::give_logbuf).
     */
    // CS TODO we need a new page-lsn update mechanism!
    template <class Logrec, class... Args>
    static rc_t log(const Args&... args)
    {
        xct_t* xd = smthread_t::xct();
        bool should_log = smlevel_0::log && smlevel_0::logging_enabled
                            && xd && xd->is_log_on();
        if (!should_log)  { return RCOK; }

        logrec_t* logrec;
        W_DO(xd->get_logbuf(logrec));
        new (logrec) Logrec {args...};

        // If it's a log for piggy-backed SSX, we call log->insert without updating _last_log
        // because this is a single log independent from other logs in outer transaction.
        if (xd->is_piggy_backed_single_log_sys_xct()) {
            w_assert1(logrec->is_single_sys_xct());
            lsn_t lsn;
            W_DO( ss_m::log->insert(*logrec, &lsn) );
            w_assert1(lsn != lsn_t::null);
            DBGOUT3(<< " SSX logged: " << logrec->type() << "\n new_lsn= " << lsn);
            return RCOK;
        }

        lsn_t lsn;
        W_DO(ss_m::log->insert(*logrec, &lsn));
        W_DO(xd->give_logbuf(logrec, lsn));

        return RCOK;
    }

    template <class Logrec, class... Args>
    static rc_t log(const btree_page_h& p, const Args&... args)
    {
        xct_t* xd = smthread_t::xct();
        bool should_log = smlevel_0::log && smlevel_0::logging_enabled
                            && xd && xd->is_log_on();
        if (!should_log)  { return RCOK; }

        logrec_t* logrec;
        W_DO(xd->get_logbuf(logrec));
        new (logrec) Logrec {p, args...};

        // set page LSN chain
        logrec->set_page_prev_lsn(p.get_page_lsn());

        // If it's a log for piggy-backed SSX, we call log->insert without updating _last_log
        // because this is a single log independent from other logs in outer transaction.
        if (xd->is_piggy_backed_single_log_sys_xct()) {
            w_assert1(logrec->is_single_sys_xct());
            lsn_t lsn;
            W_DO( ss_m::log->insert(*logrec, &lsn) );
            w_assert1(lsn != lsn_t::null);
            _update_page_lsns(&p, lsn);
            DBGOUT3(<< " SSX logged: " << logrec->type() << "\n new_lsn= " << lsn);
            return RCOK;
        }

        lsn_t lsn;
        W_DO(ss_m::log->insert(*logrec, &lsn));
        W_DO(xd->give_logbuf(logrec, lsn));
        _update_page_lsns(&p, lsn);

        return RCOK;
    }

    template <class Logrec, class... Args>
    static rc_t log(const btree_page_h& p, const btree_page_h& p2, const Args&... args)
    {
        xct_t* xd = smthread_t::xct();
        bool should_log = smlevel_0::log && smlevel_0::logging_enabled
                            && xd && xd->is_log_on();
        if (!should_log)  { return RCOK; }

        logrec_t* logrec;
        W_DO(xd->get_logbuf(logrec));
        new (logrec) Logrec {p, p2, args...};

        // set page LSN chain
        logrec->set_page_prev_lsn(p.get_page_lsn());
        // For multi-page log, also set LSN chain with a branch.
        w_assert1(logrec->is_multi_page());
        w_assert1(logrec->is_single_sys_xct());
        multi_page_log_t *multi = logrec->data_ssx_multi();
        w_assert1(multi->_page2_pid != 0);
        multi->_page2_prv = p2.get_page_lsn();

        // If it's a log for piggy-backed SSX, we call log->insert without updating _last_log
        // because this is a single log independent from other logs in outer transaction.
        if (xd->is_piggy_backed_single_log_sys_xct()) {
            w_assert1(logrec->is_single_sys_xct());
            lsn_t lsn;
            W_DO( ss_m::log->insert(*logrec, &lsn) );
            w_assert1(lsn != lsn_t::null);
            _update_page_lsns(&p, lsn);
            _update_page_lsns(&p2, lsn);
            DBGOUT3(<< " SSX logged: " << logrec->type() << "\n new_lsn= " << lsn);
            return RCOK;
        }

        lsn_t lsn;
        W_DO(ss_m::log->insert(*logrec, &lsn));
        W_DO(xd->give_logbuf(logrec, lsn));
        _update_page_lsns(&p, lsn);
        _update_page_lsns(&p2, lsn);

        return RCOK;
    }

    static void _update_page_lsns(const fixable_page_h* page, lsn_t new_lsn)
    {
        const_cast<fixable_page_h*>(page)->update_page_lsn(new_lsn);
    }
};

// CS TODO this is a temporary alias -- at some point the SM should have its
// own generic Logger template argument
using Logger = XctLogger;

#endif
