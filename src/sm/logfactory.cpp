#include "logfactory.h"

/**
 *	params:
 *		blk_size: nextBlock() will return blocks of size blk_size (in bytes).
 *		file_name: string containing the name of a CSV file containing log record statistics from a
 *				  benchmark. This file can be generated by:
 *				  			./loginspect logstats -l <path_to_log_folder>
 *		max_page_id: self-explained
 *		th: increase max_page_id after th records were generated
 *		ratio: increase max_page_id by ratio (max_page_id =* ratio)
 */
LogFactory::LogFactory(int blk_size, string file_name, int max_page_id, int th, int ratio):
						BLK_SIZE(blk_size), INCR_TH(th), INCR_RATIO(ratio), max_page_id(max_page_id),
						rng(1729),  dDist(0.0,1.0),
						generatedCount(0),  currentFile(1), currentLSN(0) {

	block_currentPos = 0;

	record = (char*) malloc(sizeof(logrec_t));
	block = (char*) malloc(sizeof(char) * BLK_SIZE);
	block_buffer = (char*) malloc(sizeof(logrec_t));

	int totalLogRecords = loadRecordStats(file_name);
	iDist = new boost::random::uniform_int_distribution<int>(1,totalLogRecords);
}

LogFactory::~LogFactory() {
	delete[] record;
	delete[] block;
	delete[] block_buffer;
	delete[] iDist;
}

LogFactory::fake_logrec_t::fake_logrec_t(){}

char* LogFactory::nextBlock() {

	/* If there is a leftover from the last logrec */
	if(block_currentPos > 0) {
		memcpy(block, block_buffer, block_currentPos);
	}

	while(block_currentPos < BLK_SIZE) {
		nextRecord(record);
		fake_logrec_t* r = (fake_logrec_t*)(record);

		/* If log_record does not fit in the remaining space of block */
		if(BLK_SIZE-block_currentPos < r->_len) {
			/* Copy what fits */
			memcpy(&block[block_currentPos], r, BLK_SIZE-block_currentPos);

			/* Save the rest for the next block */
			memcpy(block_buffer, &((char*)r)[BLK_SIZE-block_currentPos], r->_len-(BLK_SIZE-block_currentPos));
			block_currentPos = r->_len-(BLK_SIZE-block_currentPos);
			return block;
		}
		else {
			/* logrec fits, we copy all of it to the block */
			memcpy(&block[block_currentPos], r, r->_len);
		}
		block_currentPos += r->_len;
	}
	block_currentPos = 0;
	return block;
}

void LogFactory::nextRecord(char* addr) {
	fake_logrec_t* r = new(addr) fake_logrec_t();

	r->_type = nextType();
	r->_len = nextLength(r->_type);
	r->_cat = 1;
	r->_shpid = nextZipf();
	r->_tid = 1;	// transaction id
	r->_vid = 1;	// volume id
	r->_page_tag = 0;
	r->_snum = 1;	// storage number
	r->_prev = lsn_t::null;
	r->_prev_page = lsn_t::null;
	//strcpy(r->_data,"myLogRecord");
	memset(r->_data, 6, r->_len - (fake_logrec_t::hdr_sz + sizeof(lsn_t)));

	/* Check if currentLSN will overflow */
	if((currentLSN+r->_len) <= currentLSN) {
		currentFile++;
		currentLSN = 0;
	}

	*(r->_lsn_ck()) = lsn_t(currentFile,currentLSN);

	currentLSN += r->_len;

	generatedCount++;
}

/**
 * Generates a random type following a distribution based on the statistics of log records
 * created by the execution of a benchmark.
 */
int LogFactory::nextType() {
	int a = (*iDist)(rng);
	int r = cummulativeRecordsToType.lower_bound(a)->second;
	return r;
}

/* Generates a random length given a certain type, following a distribution based on the statistics
 * of log records created by the execution of a benchmark.
 */
int LogFactory::nextLength(int type) {
	map<int,int>::iterator it = typeToRecords.find(type);

	boost::random::uniform_int_distribution<int> d(1, it->second);
	int a = d(rng);
	int r = lengthStats.lower_bound(pair<int,int>(type,a))->second;
	return r;
}

/**
 * Used to generated a page_id following a Zipfian Distribution of (80,20)
 */
int LogFactory::nextZipf() {
	if(generatedCount >= INCR_TH) {
		max_page_id *= INCR_RATIO;
	}

	double h = 0.2;
	int r = (int) ((max_page_id+1) * pow(dDist(rng), (log(h)/log(1-h))));
	return max_page_id - r; /* Try to favor higher page ids */
}

/**
 *  Returns total amount of log records loaded.
 */
int LogFactory::loadRecordStats(string file_name) {
	vector<int> auxTypeVector;
	auxTypeVector.resize(logrec_t::t_max_logrec);

	int cumulativeTypeWeight = 0;
	int cumulativeLengthWeight = 0;
	int previous = -1;

	ifstream statsFile(file_name.c_str());
	while(statsFile.is_open() && !statsFile.eof()) {
		string line;
		getline(statsFile, line);
		stringstream lineStream(line);

		string field;
		int values[3];
		int i = 0;
		while(getline(lineStream, field, ',')) {
				values[i] = atoi(field.c_str());
				i++;
		}

		if(statsFile.eof()) {
			break;
		}

		pair<map<int,int>::iterator, bool > ret;
		ret = typeToRecords.insert(pair<int,int>(values[0], values[2]));
		if(!ret.second) {
			ret.first->second += values[2];
		}

		auxTypeVector[values[0]] = cumulativeTypeWeight + values[2];
		cumulativeTypeWeight = auxTypeVector[values[0]];

		/* Shit just got real */
		if(previous == values[0]) {
			cumulativeLengthWeight = cumulativeLengthWeight + values[2];
		}
		else {
			cumulativeLengthWeight = values[2];
		}
		previous = values[0];
		pair<int, int> tmp(values[0], cumulativeLengthWeight);
		lengthStats.insert(pair<pair<int,int>, int>(tmp, values[1]));

	}

	for(uint4_t i=0; i<auxTypeVector.size(); i++) {
		if(auxTypeVector[i] != 0) {
			cummulativeRecordsToType.insert(pair<int, int>(auxTypeVector[i], i));
		}
	}

	return cumulativeTypeWeight;
}

void LogFactory::printLogRecord(const logrec_t& lr) {
	/*
	cout << "[" << lr._len << ", "
			         << lr.type_str() << ", ("
			         << lr._vid << "," << lr._shpid << "), "
			         << *(lr._lsn_ck()) << "]"
			         << endl;
	*/
}

void LogFactory::printRecordStats() {
	cout << "===== typeToRecords =====" << endl;
		for (map<int, int>::iterator it=typeToRecords.begin(); it!=typeToRecords.end(); ++it) {
			cout << it->first << "," << it->second << endl;
	}

	cout << "===== cummulativeRecordsToType =====" << endl;
	for (map<int, int>::iterator it=cummulativeRecordsToType.begin(); it!=cummulativeRecordsToType.end(); ++it) {
		cout << it->first << "," << it->second << endl;
	}

	cout << "===== lengthStats =====" << endl;
	for(map<pair<int,int>, int >::iterator it = lengthStats.begin(); it != lengthStats.end(); ++it) {
			cout << it->first.first << "," << it->first.second << "," << it->second << endl;
	}
}





















